(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.10.0
(function() {
  var CanvasDrawer, GLProgramFactory;

  GLProgramFactory = require('./shaders/GLProgramFactory');

  module.exports = CanvasDrawer = (function() {
    function CanvasDrawer(canvas, fragSource, vertSource) {
      var GL, error, error1, factory, program;
      try {
        this.canvas = canvas;
        this.GL = canvas.getContext("webgl", {
          antialias: false
        });
        GL = this.GL;
        factory = new GLProgramFactory();
        console.log("GREETINGS");
        console.log(factory.constructProgramFromSources);
        program = factory.constructProgramFromSources(GL, fragSource, vertSource);
        console.log("GOODBYE");
        this.program = program;
        this.triangleArray = [-1.0, 1.0, 1.0, -1.0, 1.0, 1.0];
        this.triangleVertex = GL.createBuffer();
        GL.bindBuffer(GL.ARRAY_BUFFER, this.triangleVertex);
        GL.bufferData(GL.ARRAY_BUFFER, new Float32Array(this.triangleArray), GL.STATIC_DRAW);
        this.triangleFacesArray = [0, 1, 2];
        this.triangleFaces = GL.createBuffer();
        GL.bindBuffer(GL.ELEMENT_ARRAY_BUFFER, this.triangleFaces);
        GL.bufferData(GL.ELEMENT_ARRAY_BUFFER, new Uint16Array(this.triangleFacesArray), GL.STATIC_DRAW);
        this.position = GL.getAttribLocation(this.program, "position");
        GL.enableVertexAttribArray(this.position);
        console.log(this.triangleFaces);
        GL.clearColor(0.5, 0.5, 0.5, 0.5);
        this.GL.useProgram(this.program);
      } catch (error1) {
        error = error1;
        console.log(error);
      }
    }

    CanvasDrawer.prototype.drawFrame = function() {
      var GL;
      GL = this.GL;
      this.GL.viewport(0.0, 0.0, this.canvas.width, this.canvas.height);
      this.GL.clear(this.GL.COLOR_BUFFER_BIT);
      this.GL.bindBuffer(this.GL.ARRAY_BUFFER, this.triangleVertex);
      this.GL.vertexAttribPointer(this.position, 2, this.GL.FLOAT, false, 8, 0);
      this.GL.bindBuffer(this.GL.ELEMENT_ARRAY_BUFFER, this.triangleFaces);
      this.GL.drawElements(this.GL.TRIANGLES, 3, this.GL.UNSIGNED_SHORT, 0);
      this.GL.flush();
      return window.requestAnimationFrame((function(_this) {
        return function() {
          return _this.drawFrame();
        };
      })(this));
    };

    return CanvasDrawer;

  })();

}).call(this);

},{"./shaders/GLProgramFactory":2}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.10.0
(function() {
  var GLProgramFactory;

  module.exports = GLProgramFactory = (function() {
    function GLProgramFactory() {
      console.log("hello");
    }

    GLProgramFactory.prototype.constructShader = function(GL, source, type) {
      var shader;
      shader = GL.createShader(type);
      GL.shaderSource(shader, source);
      GL.compileShader(shader);
      if (!GL.getShaderParameter(shader, GL.COMPILE_STATUS)) {
        console.log("Failed to compiled Shader.");
        console.log(GL);
        console.log(source);
        console.log(type);
        return null;
      }
      return shader;
    };

    GLProgramFactory.prototype.constructProgramFromShaders = function(GL, __vert, __frag) {
      var program;
      program = GL.createProgram();
      GL.attachShader(program, __vert);
      GL.attachShader(program, __frag);
      GL.linkProgram(program);
      GL.validateProgram(program);
      console.log(GL.getProgramInfoLog(program));
      console.log(GL.getProgramParameter(program, GL.VALIDATE_STATUS));
      console.log("^^");
      return program;
    };

    GLProgramFactory.prototype.constructProgramFromSources = function(GL, __vert, __frag) {
      var fragshader, vertshader;
      vertshader = this.constructShader(GL, __vert, GL.VERTEX_SHADER);
      fragshader = this.constructShader(GL, __frag, GL.FRAGMENT_SHADER);
      return this.constructProgramFromShaders(GL, vertshader, fragshader);
    };

    return GLProgramFactory;

  })();

}).call(this);

},{}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.10.0
(function() {
  var ShaderReader;

  module.exports = ShaderReader = (function() {
    function ShaderReader(id) {
      var error, error1, shader;
      try {
        shader = document.getElementById(id);
        this.shaderSource = shader.getAttribute("shader_text");
        this.success = true;
      } catch (error1) {
        error = error1;
        console.log(error);
        this.success = false;
      }
    }

    ShaderReader.prototype.didSucced = function() {
      return this.success;
    };

    ShaderReader.prototype.toString = function() {
      if (this.didSucced()) {
        return this.shaderSource;
      }
      return null;
    };

    return ShaderReader;

  })();

}).call(this);

},{}],4:[function(require,module,exports){
// Generated by CoffeeScript 1.10.0
(function() {
  var CanvasDrawer, ShaderReader, body, main, resizeCanvas;

  ShaderReader = require('./lib/shaders/ShaderReader');

  CanvasDrawer = require('./lib/CanvasDrawer');

  console.log("Hello");

  main = function() {
    var canvas, frag, frags, vert, verts;
    resizeCanvas();
    frag = new ShaderReader("frag");
    frags = frag.toString();
    vert = new ShaderReader("vert");
    verts = vert.toString();
    console.log(frags);
    console.log(verts);
    console.log("UPPPPP");
    canvas = document.getElementById("gl_canvas");
    this.canvasDrawer = new CanvasDrawer(canvas, verts, frags);
    this.canvasDrawer.drawFrame();
    return null;
  };

  resizeCanvas = function() {
    var canvas, div, p, w;
    div = document.getElementById("p_holder");
    p = document.getElementById("canvas_holder");
    canvas = document.getElementById("gl_canvas");
    p.width = div.innerWidth;
    p.height = div.innerHeight;
    w = getComputedStyle(p).getPropertyValue("width");
    w = parseInt(w.replace("px", "")) * 0.8;
    canvas.width = w;
    canvas.height = window.innerHeight * 0.8;
    console.log([canvas.width, canvas.height]);
    return [canvas.width, canvas.height];
  };

  body = document.body;

  window["main"] = (function(_this) {
    return function() {
      return main();
    };
  })(this);

  window["resizeCanvas"] = (function(_this) {
    return function() {
      return resizeCanvas();
    };
  })(this);

}).call(this);

},{"./lib/CanvasDrawer":1,"./lib/shaders/ShaderReader":3}]},{},[4]);
